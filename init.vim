"" General
set number	" Show line numbers
set linebreak	" Break lines at word (requires Wrap lines) set showbreak=+++	" Wrap-broken line prefix
set textwidth=100	" Line wrap (number of cols)
set showmatch	" Highlight matching brace
" set spell	" Enable spell-checking

set hlsearch	" Highlight all search results
set smartcase	" Enable smart-case search
set ignorecase	" Always case-insensitive
set incsearch	" Searches for strings incrementally

set autoindent	" Auto-indent new lines
set cindent	" Use 'C' style program indenting
set expandtab	" Use spaces instead of tabs
set shiftwidth=2	" Number of auto-indent spaces
set smartindent	" Enable smart-indent
set smarttab	" Enable smart-tabs
set softtabstop=2	" Number of spaces per Tab

"" Advanced
set confirm	" Prompt confirmation dialogs
set ruler	" Show row and column ruler information
set showtabline=2	" Show tab bar
set cmdheight=2	" Command line height

set undolevels=2000	" Number of undo levels
set backspace=indent,eol,start	" Backspace behaviour
"" Generated by VimConfig.com


" == VIM PLUG ============================================
call plug#begin('~/.nvim/plugged')
" ------------------------- COC --------------------------
" coc for tslinting, auto complete and prettier
Plug 'neoclide/coc.nvim', {'do': 'yarn install --frozen-lockfile'}

" coc extensions
let g:coc_global_extensions = ['coc-tslint-plugin', 'coc-tsserver', 'coc-emmet', 'coc-css', 'coc-html', 'coc-json', 'coc-yank', 'coc-prettier']

" ----------------------- VIM TSX ------------------------
" by default, if you open tsx file, neovim does not show syntax colors
" vim-tsx will do all the coloring for jsx in the .tsx file
Plug 'ianks/vim-tsx'

" ------------------- TYPESCRIPT-VIM ---------------------
Plug 'leafgarland/typescript-vim'

" ----------------------- THEME --------------------------
" most importantly you need a good color scheme to write good code :D
Plug 'dikiaap/minimalist'

" --------------------- EXPLORER -------------------------
" Nerdtree is a file explorer for Vim/Neovim. It will generate a file navigation window just like an IDE.
" We can operate on files easily in the nerdtree window.
" In this post, I will summarize some of its configurations and usages.
Plug 'scrooloose/nerdtree'

" -------------- HEADER FILES SWITCHING ------------------
" Switching between source and header files is another common operation when working with C++.
Plug 'derekwyatt/vim-fswitch'

" ------------------- CODE STRUCTURE ---------------------
" Vista.vim get ability to browse the structure of the current source file.
" What classes, functions, macroses are defined there.
Plug 'liuchengxu/vista.vim'

" -------------------- VIMSPECTOR ------------------------
" Interactive debugging inside vim
Plug 'puremourning/vimspector', {
  \ 'do': 'python3 install_gadget.py --enable-vscode-cpptools'
  \ }

" --------------------- VIMTEX --------------------------
" The LaTeX plugin I’m using in Vim is vimtex.
" It provides syntax highlighting, table of contents view, synctex, etc.
Plug 'lervag/vimtex'
let g:tex_flavor='latex'
let g:vimtex_view_method='zathura'
let g:vimtex_quickfix_mode=0
" The last two lines configure the concealment.
" This is a feature where LaTeX code is replaced or made invisible when your cursor is not on that line.
set conceallevel=1
let g:tex_conceal='abdmg'

" ------------------- ULTISNIPS --------------------------
" Track the engine.
Plug 'sirver/ultisnips'

" ------------ SNIPMATE & ULTISNIP SNIPPETS --------------
" Snippets are separated from the engine. Add this if you want them:
Plug 'honza/vim-snippets'

" Trigger configuration. You need to change this to something other than <tab> if you use one of the following:
" - https://github.com/Valloric/YouCompleteMe
" - https://github.com/nvim-lua/completion-nvim
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

" ------------------- VIM-CPP-MODERN ---------------------
" Enhanced C and C++ syntax highlighting:
Plug 'bfrg/vim-cpp-modern'

" --------------- MARKDOWN-PREVIEW.NVIM ------------------
"  Pluging adding preview for markdown files
 Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() }, 'for': ['markdown', 'vim-plug']}

call plug#end()
" == VIMPLUG END =========================================

syntax on 
colorscheme minimalist

" == AUTOCMD =============================================
" by default .ts file are not identified as typescript and .tsx files are not
" identified as typescript react file, so add following
au BufNewFile,BufRead *.ts setlocal filetype=typescript
au BufNewFile,BufRead *.tsx setlocal filetype=typescript.tsx
" == AUTOCMD END =========================================

" Set cursor type to underline
:set guicursor+=n:hor20-Cursor/lCursor
:set guicursor+=i:hor20-Cursor/lCursor

" Set cursor selection colors
highlight Cursor guifg=white guibg=black
highlight lCursor guifg=white guibg=steelblue

" Adding highlight for accidently added whitespaces in end of line
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
au BufWinEnter * match ExtraWhitespace /\s\+$/
au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
au InsertLeave * match ExtraWhitespace /\s\+$/
au BufWinLeave * call clearmatches()

" By default, when you press K, vim grabs the keyword under the cursor, separated by iskeyword symbols.
" There is one problem. The : symbol often found in C++ definitions is not included in the iskeyword array.
" So, for example, when you press K under the keyword std::string,
" vim will try to find the man page for std, instead of the full identifier.
" Function for fix:
function! s:JbzCppMan()
    let old_isk = &iskeyword
    setl iskeyword+=:
    let str = expand("<cword>")
    let &l:iskeyword = old_isk
    execute 'Man ' . str
endfunction
command! JbzCppMan :call s:JbzCppMan()

" Remaping the default K key binding to use our function in C++
au FileType cpp nnoremap <buffer>K :JbzCppMan<CR>

" Autoswitching between header and source files in projects for C++
au BufEnter *.h  let b:fswitchdst = "c,cpp,cc,m"
au BufEnter *.cc let b:fswitchdst = "h,hpp"

" There is also one more nuance.
" A lot of C++ projects follow this convention for splitting headers and sources:
"
" include/<project-name>/<path>/some_header.h
" src/<path>/some_source.cpp
"
" To make FSwitch work with such cases (when switching from header to source), adding this:
au BufEnter *.h let b:fswitchdst = 'c,cpp,m,cc' | let b:fswitchlocs = 'reg:|include|source/**|'

" It also will be convenient to set up some key bindings for FSwitch:
nnoremap <silent> <A-o> :FSHere<cr>
" Extra hotkeys to open header/source in the split
nnoremap <silent> <localleader>oh :FSSplitLeft<cr>
nnoremap <silent> <localleader>oj :FSSplitBelow<cr>
nnoremap <silent> <localleader>ok :FSSplitAbove<cr>
nnoremap <silent> <localleader>ol :FSSplitRight<cr>

" Setting up keybindings for NERDTree
nnoremap <leader>n :NERDTreeFocus<CR>
nnoremap <C-n> :NERDTree<CR>
nnoremap <C-t> :NERDTreeToggle<CR>
nnoremap <C-f> :NERDTreeFind<CR>

" Add a convenient key binding to toggle Vista split:
nnoremap <silent> <A-6> :Vista!!<CR>

" Another feature of vista.vim is that it shares information of the symbol under the cursor. Using this we can display the current function name in the status line. This helps us navigate when moving through a large file.
function! LightlineCurrentFunctionVista() abort
  let l:method = get(b:, 'vista_nearest_method_or_function', '')
  if l:method != ''
    let l:method = '[' . l:method . ']'
  endif
  return l:method
endfunction
au VimEnter * call vista#RunForNearestMethodOrFunction()

" Set up some key bindings for vimspector:
command! -nargs=+ Vfb call vimspector#AddFunctionBreakpoint(<f-args>)

nnoremap <localleader>gd :call vimspector#Launch()<cr>
nnoremap <localleader>gc :call vimspector#Continue()<cr>
nnoremap <localleader>gs :call vimspector#Stop()<cr>
nnoremap <localleader>gR :call vimspector#Restart()<cr>
nnoremap <localleader>gp :call vimspector#Pause()<cr>
nnoremap <localleader>gb :call vimspector#ToggleBreakpoint()<cr>
nnoremap <localleader>gB :call vimspector#ToggleConditionalBreakpoint()<cr>
nnoremap <localleader>gn :call vimspector#StepOver()<cr>
nnoremap <localleader>gi :call vimspector#StepInto()<cr>
nnoremap <localleader>go :call vimspector#StepOut()<cr>
nnoremap <localleader>gr :call vimspector#RunToCursor()<cr>

" Helper function for snippets
function! s:JbzRemoveDebugPrints()
  let save_cursor = getcurpos()
  :g/\/\/\ prdbg$/d
  call setpos('.', save_cursor)
endfunction
command! JbzRemoveDebugPrints call s:JbzRemoveDebugPrints()

" Function will remove our print statements. We can also define a convenient key binding:
au FileType c,cpp nnoremap <buffer><leader>rd :JbzRemoveDebugPrints<CR>

" Clang-format is a tool to automatically format 
" C/C++/Java/JavaScript/Objective-C/Protobuf/C# code, 
" so that developers don’t need to worry about style issues during code reviews. 
" It can be simply integrated into vim.
" Install clang-format tool from your distribution repositories
" and create this function in the vim configuration:
function! s:JbzClangFormat(first, last)
  let l:winview = winsaveview()
  execute a:first . "," . a:last . "!clang-format"
  call winrestview(l:winview)
endfunction
command! -range=% JbzClangFormat call <sid>JbzClangFormat (<line1>, <line2>)

" Autoformatting with clang-format
au FileType c,cpp nnoremap <buffer><leader>lf :<C-u>JbzClangFormat<CR>
au FileType c,cpp vnoremap <buffer><leader>lf :JbzClangFormat<CR>

" MarkdownPreview Config with description of every parameter:
"
" set to 1, nvim will open the preview window after entering the markdown buffer
" default: 0
let g:mkdp_auto_start = 0

" set to 1, the nvim will auto close current preview window when change
" from markdown buffer to another buffer
" default: 1
let g:mkdp_auto_close = 1

" set to 1, the vim will refresh markdown when save the buffer or
" leave from insert mode, default 0 is auto refresh markdown as you edit or
" move the cursor
" default: 0
let g:mkdp_refresh_slow = 0

" set to 1, the MarkdownPreview command can be use for all files,
" by default it can be use in markdown file
" default: 0
let g:mkdp_command_for_global = 0

" set to 1, preview server available to others in your network
" by default, the server listens on localhost (127.0.0.1)
" default: 0
let g:mkdp_open_to_the_world = 0

" use custom IP to open preview page
" useful when you work in remote vim and preview on local browser
" more detail see: https://github.com/iamcco/markdown-preview.nvim/pull/9
" default empty
let g:mkdp_open_ip = ''

" specify browser to open preview page
" for path with space
" valid: `/path/with\ space/xxx`
" invalid: `/path/with\\ space/xxx`
" default: ''
let g:mkdp_browser = ''

" set to 1, echo preview page url in command line when open preview page
" default is 0
let g:mkdp_echo_preview_url = 0

" a custom vim function name to open preview page
" this function will receive url as param
" default is empty
let g:mkdp_browserfunc = ''

" options for markdown render
" mkit: markdown-it options for render
" katex: katex options for math
" uml: markdown-it-plantuml options
" maid: mermaid options
" disable_sync_scroll: if disable sync scroll, default 0
" sync_scroll_type: 'middle', 'top' or 'relative', default value is 'middle'
"   middle: mean the cursor position alway show at the middle of the preview page
"   top: mean the vim top viewport alway show at the top of the preview page
"   relative: mean the cursor position alway show at the relative positon of the preview page
" hide_yaml_meta: if hide yaml metadata, default is 1
" sequence_diagrams: js-sequence-diagrams options
" content_editable: if enable content editable for preview page, default: v:false
" disable_filename: if disable filename header for preview page, default: 0
let g:mkdp_preview_options = {
    \ 'mkit': {},
    \ 'katex': {},
    \ 'uml': {},
    \ 'maid': {},
    \ 'disable_sync_scroll': 0,
    \ 'sync_scroll_type': 'middle',
    \ 'hide_yaml_meta': 1,
    \ 'sequence_diagrams': {},
    \ 'flowchart_diagrams': {},
    \ 'content_editable': v:false,
    \ 'disable_filename': 0,
    \ 'toc': {}
    \ }

" use a custom markdown style must be absolute path
" like '/Users/username/markdown.css' or expand('~/markdown.css')
let g:mkdp_markdown_css = ''

" use a custom highlight style must absolute path
" like '/Users/username/highlight.css' or expand('~/highlight.css')
let g:mkdp_highlight_css = ''

" use a custom port to start server or empty for random
let g:mkdp_port = ''

" preview page title
" ${name} will be replace with the file name
let g:mkdp_page_title = '「${name}」'

" recognized filetypes
" these filetypes will have MarkdownPreview... commands
let g:mkdp_filetypes = ['markdown']

" set default theme (dark or light)
" By default the theme is define according to the preferences of the system
let g:mkdp_theme = 'dark'

" Keybinding for start preview:
nmap <C-m> <Plug>MarkdownPreview
nmap <C-m> <Plug>MarkdownPreviewStop
nmap <A-m> <Plug>MarkdownPreviewToggle
