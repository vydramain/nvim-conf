"" General
set number	" Show line numbers
set linebreak	" Break lines at word (requires Wrap lines) set showbreak=+++	" Wrap-broken line prefix
set textwidth=100	" Line wrap (number of cols)
set showmatch	" Highlight matching brace
" set spell	" Enable spell-checking

set hlsearch	" Highlight all search results
set smartcase	" Enable smart-case search
set ignorecase	" Always case-insensitive
set incsearch	" Searches for strings incrementally
 
set autoindent	" Auto-indent new lines
set cindent	" Use 'C' style program indenting
set expandtab	" Use spaces instead of tabs
set shiftwidth=2	" Number of auto-indent spaces
set smartindent	" Enable smart-indent
set smarttab	" Enable smart-tabs
set softtabstop=2	" Number of spaces per Tab
 
"" Advanced
set confirm	" Prompt confirmation dialogs
set ruler	" Show row and column ruler information
set showtabline=2	" Show tab bar
set cmdheight=2	" Command line height
 
set undolevels=2000	" Number of undo levels
set backspace=indent,eol,start	" Backspace behaviour
"" Generated by VimConfig.com


" == VIM PLUG ============================================
call plug#begin('~/.nvim/plugged')
" ------------------------- COC --------------------------
" coc for tslinting, auto complete and prettier
Plug 'neoclide/coc.nvim', {'do': 'yarn install --frozen-lockfile'}

" coc extensions
let g:coc_global_extensions = ['coc-tslint-plugin', 'coc-tsserver', 'coc-emmet', 'coc-css', 'coc-html', 'coc-json', 'coc-yank', 'coc-prettier']

" ----------------------- VIM TSX ------------------------
" by default, if you open tsx file, neovim does not show syntax colors
" vim-tsx will do all the coloring for jsx in the .tsx file
Plug 'ianks/vim-tsx'

" ----------------------- VIM TSX ------------------------
" by default, if you open tsx file, neovim does not show syntax colors
" typescript-vim will do all the coloring for typescript keywords
Plug 'leafgarland/typescript-vim'

" ----------------------- THEME --------------------------
" most importantly you need a good color scheme to write good code :D
Plug 'dikiaap/minimalist'

" --------------------- EXPLORER -------------------------
" Nerdtree is a file explorer for Vim/Neovim. It will generate a file navigation window just like an IDE. 
" We can operate on files easily in the nerdtree window. 
" In this post, I will summarize some of its configurations and usages.
Plug 'scrooloose/nerdtree'

" -------------- HEADER FILES SWITCHING ------------------
" Switching between source and header files is another common operation when working with C++.
Plug 'derekwyatt/vim-fswitch'

" ------------------- CODE STRUCTURE ---------------------
" Vista.vim get ability to browse the structure of the current source file.
" What classes, functions, macroses are defined there.
Plug 'liuchengxu/vista.vim'

" -------------------- VIMSPECTOR ------------------------
" Interactive debugging inside vim
Plug 'puremourning/vimspector', {
  \ 'do': 'python3 install_gadget.py --enable-vscode-cpptools'
  \ }

" --------------------- VIMTEX --------------------------
" The LaTeX plugin I’m using in Vim is vimtex.
" It provides syntax highlighting, table of contents view, synctex, etc.
Plug 'lervag/vimtex'
let g:tex_flavor='latex'
let g:vimtex_view_method='zathura'
let g:vimtex_quickfix_mode=0
" The last two lines configure the concealment.
" This is a feature where LaTeX code is replaced or made invisible when your cursor is not on that line.
set conceallevel=1
let g:tex_conceal='abdmg'

" ------------------- ULTISNIPS --------------------------
" Track the engine.
Plug 'sirver/ultisnips'

" ------------ SNIPMATE & ULTISNIP SNIPPETS --------------
" Snippets are separated from the engine. Add this if you want them:
Plug 'honza/vim-snippets'

" Trigger configuration. You need to change this to something other than <tab> if you use one of the following:
" - https://github.com/Valloric/YouCompleteMe
" - https://github.com/nvim-lua/completion-nvim
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

" ------------------- VIM-CPP-MODERN ---------------------
" Enhanced C and C++ syntax highlighting:
Plug 'bfrg/vim-cpp-modern'

call plug#end()
" == VIMPLUG END =========================================

syntax on 
colorscheme minimalist

" == AUTOCMD =============================================
" by default .ts file are not identified as typescript and .tsx files are not
" identified as typescript react file, so add following
au BufNewFile,BufRead *.ts setlocal filetype=typescript
au BufNewFile,BufRead *.tsx setlocal filetype=typescript.tsx
" == AUTOCMD END =========================================

" Set cursor type to underline
:set guicursor+=n:hor20-Cursor/lCursor
:set guicursor+=i:hor20-Cursor/lCursor

" Set cursor selection colors
highlight Cursor guifg=white guibg=black
highlight lCursor guifg=white guibg=steelblue

" Adding highlight for accidently added whitespaces in end of line
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
au BufWinEnter * match ExtraWhitespace /\s\+$/
au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
au InsertLeave * match ExtraWhitespace /\s\+$/
au BufWinLeave * call clearmatches()

" By default, when you press K, vim grabs the keyword under the cursor, separated by iskeyword symbols.
" There is one problem. The : symbol often found in C++ definitions is not included in the iskeyword array.
" So, for example, when you press K under the keyword std::string,
" vim will try to find the man page for std, instead of the full identifier.
" Function for fix:
function! s:JbzCppMan()
    let old_isk = &iskeyword
    setl iskeyword+=:
    let str = expand("<cword>")
    let &l:iskeyword = old_isk
    execute 'Man ' . str
endfunction
command! JbzCppMan :call s:JbzCppMan()

" Remaping the default K key binding to use our function in C++
au FileType cpp nnoremap <buffer>K :JbzCppMan<CR>

" Autoswitching between header and source files in projects for C++
au BufEnter *.h  let b:fswitchdst = "c,cpp,cc,m"
au BufEnter *.cc let b:fswitchdst = "h,hpp"

" There is also one more nuance.
" A lot of C++ projects follow this convention for splitting headers and sources:
"
" include/<project-name>/<path>/some_header.h
" src/<path>/some_source.cpp
"
" To make FSwitch work with such cases (when switching from header to source), adding this:
au BufEnter *.h let b:fswitchdst = 'c,cpp,m,cc' | let b:fswitchlocs = 'reg:|include|source/**|'

" It also will be convenient to set up some key bindings for FSwitch:
nnoremap <silent> <A-o> :FSHere<cr>
" Extra hotkeys to open header/source in the split
nnoremap <silent> <localleader>oh :FSSplitLeft<cr>
nnoremap <silent> <localleader>oj :FSSplitBelow<cr>
nnoremap <silent> <localleader>ok :FSSplitAbove<cr>
nnoremap <silent> <localleader>ol :FSSplitRight<cr>

" Setting up keybindings for NERDTree
nnoremap <leader>n :NERDTreeFocus<CR>
nnoremap <C-n> :NERDTree<CR>
nnoremap <C-t> :NERDTreeToggle<CR>
nnoremap <C-f> :NERDTreeFind<CR>

" Add a convenient key binding to toggle Vista split:
nnoremap <silent> <A-6> :Vista!!<CR>

" Another feature of vista.vim is that it shares information of the symbol under the cursor. Using this we can display the current function name in the status line. This helps us navigate when moving through a large file.
function! LightlineCurrentFunctionVista() abort
  let l:method = get(b:, 'vista_nearest_method_or_function', '')
  if l:method != ''
    let l:method = '[' . l:method . ']'
  endif
  return l:method
endfunction
au VimEnter * call vista#RunForNearestMethodOrFunction()

" Set up some key bindings for vimspector:
command! -nargs=+ Vfb call vimspector#AddFunctionBreakpoint(<f-args>)

nnoremap <localleader>gd :call vimspector#Launch()<cr>
nnoremap <localleader>gc :call vimspector#Continue()<cr>
nnoremap <localleader>gs :call vimspector#Stop()<cr>
nnoremap <localleader>gR :call vimspector#Restart()<cr>
nnoremap <localleader>gp :call vimspector#Pause()<cr>
nnoremap <localleader>gb :call vimspector#ToggleBreakpoint()<cr>
nnoremap <localleader>gB :call vimspector#ToggleConditionalBreakpoint()<cr>
nnoremap <localleader>gn :call vimspector#StepOver()<cr>
nnoremap <localleader>gi :call vimspector#StepInto()<cr>
nnoremap <localleader>go :call vimspector#StepOut()<cr>
nnoremap <localleader>gr :call vimspector#RunToCursor()<cr>

" Helper function for snippets
function! s:JbzRemoveDebugPrints()
  let save_cursor = getcurpos()
  :g/\/\/\ prdbg$/d
  call setpos('.', save_cursor)
endfunction
command! JbzRemoveDebugPrints call s:JbzRemoveDebugPrints()

" Function will remove our print statements. We can also define a convenient key binding:
au FileType c,cpp nnoremap <buffer><leader>rd :JbzRemoveDebugPrints<CR>

" Clang-format is a tool to automatically format 
" C/C++/Java/JavaScript/Objective-C/Protobuf/C# code, 
" so that developers don’t need to worry about style issues during code reviews. 
" It can be simply integrated into vim.
" Install clang-format tool from your distribution repositories
" and create this function in the vim configuration:
function! s:JbzClangFormat(first, last)
  let l:winview = winsaveview()
  execute a:first . "," . a:last . "!clang-format"
  call winrestview(l:winview)
endfunction
command! -range=% JbzClangFormat call <sid>JbzClangFormat (<line1>, <line2>)

" Autoformatting with clang-format
au FileType c,cpp nnoremap <buffer><leader>lf :<C-u>JbzClangFormat<CR>
au FileType c,cpp vnoremap <buffer><leader>lf :JbzClangFormat<CR>
